diff --git a/src/bios.rs b/src/bios.rs
index 4f6764f..d3e53db 100644
--- a/src/bios.rs
+++ b/src/bios.rs
@@ -16,7 +16,7 @@ use crate::model::*;
 use crate::packagesystem;
 
 // grub2-install file path
-pub(crate) const GRUB_BIN: &str = "usr/sbin/grub2-install";
+pub(crate) const GRUB_BIN: &str = "usr/bin/grub-install";
 
 #[cfg(target_arch = "powerpc64")]
 fn target_device(device: &str) -> Result<Cow<str>> {
@@ -151,10 +151,10 @@ impl Component for Bios {
     // - Remove symlink "/boot/grub2/grub.cfg"
     // - Replace "/boot/grub2/grub.cfg" symlink with new static "grub.cfg"
     fn migrate_static_grub_config(&self, sysroot_path: &str, destdir: &openat::Dir) -> Result<()> {
-        let grub = "boot/grub2";
+        let grub = "boot/grub";
         // sysroot_path is /, destdir is Dir of /
         let grub_config_path = Utf8PathBuf::from(sysroot_path).join(grub);
-        let grub_config_dir = destdir.sub_dir(grub).context("Opening boot/grub2")?;
+        let grub_config_dir = destdir.sub_dir(grub).context("Opening boot/grub")?;
 
         let grub_config = grub_config_path.join(grubconfigs::GRUBCONFIG);
 
diff --git a/src/bootupd.rs b/src/bootupd.rs
index 0065300..ba18b72 100644
--- a/src/bootupd.rs
+++ b/src/bootupd.rs
@@ -602,8 +602,8 @@ pub(crate) fn client_run_migrate_static_grub_config() -> Result<()> {
     // Remount /boot read write just for this unit (we are called in a slave mount namespace by systemd)
     ensure_writable_boot()?;
 
-    let grub_config_dir = PathBuf::from("/boot/grub2");
-    let dirfd = openat::Dir::open(&grub_config_dir).context("Opening /boot/grub2")?;
+    let grub_config_dir = PathBuf::from("/boot/grub");
+    let dirfd = openat::Dir::open(&grub_config_dir).context("Opening /boot/grub")?;
 
     // We mark the bootloader as BLS capable to disable the ostree-grub2 logic.
     // We can do that as we know that we are run after the bootloader has been
@@ -612,10 +612,10 @@ pub(crate) fn client_run_migrate_static_grub_config() -> Result<()> {
     // manually overwrites the (soon) static GRUB config by calling `grub2-mkconfig`.
     // We need this until we can rely on ostree-grub2 being removed from the image.
     println!("Marking bootloader as BLS capable...");
-    _ = File::create("/boot/grub2/.grub2-blscfg-supported");
+    _ = File::create("/boot/grub/.grub2-blscfg-supported");
 
     // Migrate /boot/grub2/grub.cfg to a static GRUB config if it is a symlink
-    let grub_config_filename = PathBuf::from("/boot/grub2/grub.cfg");
+    let grub_config_filename = PathBuf::from("/boot/grub/grub.cfg");
     match dirfd.read_link("grub.cfg") {
         Err(_) => {
             println!(
@@ -631,7 +631,7 @@ pub(crate) fn client_run_migrate_static_grub_config() -> Result<()> {
             current_config.push(path);
 
             // Backup the current GRUB config which is hopefully working right now
-            let backup_config = PathBuf::from("/boot/grub2/grub.cfg.backup");
+            let backup_config = PathBuf::from("/boot/grub/grub.cfg.backup");
             println!(
                 "Creating a backup of the current GRUB config '{}' in '{}'...",
                 current_config.display(),
diff --git a/src/grub2/grub-static-efi.cfg b/src/grub2/grub-static-efi.cfg
index 3d552c3..8b0f5b7 100644
--- a/src/grub2/grub-static-efi.cfg
+++ b/src/grub2/grub-static-efi.cfg
@@ -13,11 +13,11 @@ else
     search --label boot --set prefix --no-floppy
   fi
 fi
-if [ -d ($prefix)/grub2 ]; then
-  set prefix=($prefix)/grub2
+if [ -d ($prefix)/grub ]; then
+  set prefix=($prefix)/grub
   configfile $prefix/grub.cfg
 else
-  set prefix=($prefix)/boot/grub2
+  set prefix=($prefix)/boot/grub
   configfile $prefix/grub.cfg
 fi
 boot
diff --git a/src/grub2/grub-static-pre.cfg b/src/grub2/grub-static-pre.cfg
index a092008..8441bf7 100644
--- a/src/grub2/grub-static-pre.cfg
+++ b/src/grub2/grub-static-pre.cfg
@@ -2,7 +2,7 @@
 # Changes:
 #   - Dropped Ignition glue, that can be injected into platform.cfg
 # petitboot doesn't support -e and doesn't support an empty path part
-if [ -d (md/md-boot)/grub2 ]; then
+if [ -d (md/md-boot)/grub ]; then
   # fcct currently creates /boot RAID with superblock 1.0, which allows
   # component partitions to be read directly as filesystems.  This is
   # necessary because transposefs doesn't yet rerun grub2-install on BIOS,
@@ -19,7 +19,7 @@ if [ -d (md/md-boot)/grub2 ]; then
   #    future module loads to come from the RAID, so we reset $prefix.
   #    (On UEFI, the stub grub.cfg has already set $prefix properly.)
   set boot=md/md-boot
-  set prefix=($boot)/grub2
+  set prefix=($boot)/grub
 else
   if [ -f ${config_directory}/bootuuid.cfg ]; then
     source ${config_directory}/bootuuid.cfg
diff --git a/src/grubconfigs.rs b/src/grubconfigs.rs
index 17be02a..b28d46f 100644
--- a/src/grubconfigs.rs
+++ b/src/grubconfigs.rs
@@ -11,7 +11,7 @@ use openat_ext::OpenatDirExt;
 use crate::freezethaw::fsfreeze_thaw_cycle;
 
 /// The subdirectory of /boot we use
-const GRUB2DIR: &str = "grub2";
+const GRUB2DIR: &str = "grub";
 const CONFIGDIR: &str = "/usr/lib/bootupd/grub2-static";
 const DROPINDIR: &str = "configs.d";
 // The related grub files
@@ -138,14 +138,14 @@ pub(crate) fn install(
     Ok(())
 }
 
-#[context("Create file boot/grub2/grubenv")]
+#[context("Create file boot/grub/grubenv")]
 fn write_grubenv(bootdir: &openat::Dir) -> Result<()> {
-    let grubdir = &bootdir.sub_dir(GRUB2DIR).context("Opening boot/grub2")?;
+    let grubdir = &bootdir.sub_dir(GRUB2DIR).context("Opening boot/grub")?;
 
     if grubdir.exists(GRUBENV)? {
         return Ok(());
     }
-    let editenv = Path::new("/usr/bin/grub2-editenv");
+    let editenv = Path::new("/usr/bin/grub-editenv");
     if !editenv.exists() {
         anyhow::bail!("Failed to find {:?}", editenv);
     }
@@ -167,29 +167,29 @@ mod tests {
         let td = tempfile::tempdir()?;
         let tdp = td.path();
         let td = openat::Dir::open(tdp)?;
-        std::fs::create_dir_all(tdp.join("boot/grub2"))?;
+        std::fs::create_dir_all(tdp.join("boot/grub"))?;
         std::fs::create_dir_all(tdp.join("boot/efi/EFI/BOOT"))?;
         std::fs::create_dir_all(tdp.join("boot/efi/EFI/fedora"))?;
         install(&td, None, Some("fedora"), false).unwrap();
 
-        assert!(td.exists("boot/grub2/grub.cfg")?);
+        assert!(td.exists("boot/grub/grub.cfg")?);
         assert!(td.exists("boot/efi/EFI/fedora/grub.cfg")?);
         Ok(())
     }
     #[test]
     fn test_write_grubenv() -> Result<()> {
         // Skip this test if grub2-editenv is not installed
-        let editenv = Path::new("/usr/bin/grub2-editenv");
+        let editenv = Path::new("/usr/bin/grub-editenv");
         if !editenv.try_exists()? {
             return Ok(());
         }
         let td = tempfile::tempdir()?;
         let tdp = td.path();
-        std::fs::create_dir_all(tdp.join("boot/grub2"))?;
+        std::fs::create_dir_all(tdp.join("boot/grub"))?;
         let td = openat::Dir::open(&tdp.join("boot"))?;
         write_grubenv(&td)?;
 
-        assert!(td.exists("grub2/grubenv")?);
+        assert!(td.exists("grub/grubenv")?);
         Ok(())
     }
 }
